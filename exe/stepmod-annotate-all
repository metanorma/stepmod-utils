#!/usr/bin/env ruby

require "concurrent"
require "stepmod/utils/stepmod_file_annotator"
require "fileutils"

stepmod_dir = ARGV.first || Dir.pwd
stepmod_dir = Pathname.new(stepmod_dir.gsub("\\", "/"))

def all_express_files(stepmod_dir)
  index_file = File.read(File.join(stepmod_dir, "repository_index.xml"))
  index = Nokogiri::XML(index_file).root

  files = []
  index.xpath("modules/module").each do |item|
    files << "#{stepmod_dir}/data/modules/#{item['name']}/arm.exp"
    files << "#{stepmod_dir}/data/modules/#{item['name']}/mim.exp"
  end

  index.xpath("resources/resource").each do |item|
    next if item["name"] == "iso13584_expressions_schema"

    files << "#{stepmod_dir}/data/resources/#{item['name']}/#{item['name']}.exp"
  end

  index.xpath("business_object_models/business_object_model").each do |item|
    files << "#{stepmod_dir}/data/business_object_models/#{item['name']}/bom.exp"
    files << "#{stepmod_dir}/data/business_object_models/#{item['name']}/DomainModel.exp"
  end

  files.filter { |file| File.exist?(file) }
end

filename_cache = {}

# On MacOS File.exist? was behaving case sensitive while on
# Github Actions it was behaving as case in-sensitive, e.g
# File.exist?(`../resource_docs/geometric_and_topological_representation/RationalLRsurf.gif`)
# was returning true on MacOS and false on Github Action runner. Because
# the original filepath was `geometric_and_topological_representation/RationalLRSurf.gif` (notice the capital `S` for Surf.gif)
# So this method is to find the actual path of the file based on
# downcased name of the file,
#
# Example:
#
# Given `../resource_docs/geometric_and_topological_representation/RationalLRsurf.gif`
#   return `../resource_docs/geometric_and_topological_representation/RationalLRSurf.gif`
# It will return nil if the file does not exist
def file_system_path(filepath)
  dir = File.dirname(filepath)
  filename = File.basename(filepath)

  return filename_cache[dir][filename.downcase] if filename_cache[dir]

  files = Dir.glob(File.join(dir, "*")).map { |f| [f.downcase, f] }.to_h
  filename_cache[dir] = files

  filename_cache[dir][filename.downcase]
end

MAX_THREADS = 1 #[2, Concurrent.processor_count].max * 2
MAX_QUEUE_SIZE = MAX_THREADS * 4
# https://github.com/ruby-concurrency/concurrent-ruby/blob/master/docs-source/thread_pools.md
# pool = Concurrent::ThreadPoolExecutor.new(
#   min_threads: MAX_THREADS,
#   max_threads: MAX_THREADS,
#   max_queue: MAX_QUEUE_SIZE,
#   fallback_policy: :caller_runs,
# )

files = all_express_files(stepmod_dir)

files.each do |file|
  puts "#{Thread.current.object_id}: Processing #{file}"

  result = Stepmod::Utils::StepmodFileAnnotator.new(
    express_file: file,
    stepmod_dir: stepmod_dir,
  ).call

  annotated_file_name = "#{File.basename(file, '.exp')}_annotated.exp"
  annotated_file_path = File.join(File.dirname(file), annotated_file_name)

  File.open(annotated_file_path, "w") do |annotated_file|
    annotated_file.puts(result[:annotated_text])
  end

  result[:images_references].each do |source, destination|
    source_path = file_system_path(File.join(stepmod_dir, "data", source))
    destination_path = File.join(File.dirname(file), destination)

    puts "#{Thread.current.object_id}:     Starting to copy file from #{source_path} to #{destination_path}"
    puts "#{Thread.current.object_id}:     Source File exist: #{File.exist?(source_path)}"
    next if !source_path

    FileUtils.cp(source_path, destination_path)
    puts "#{Thread.current.object_id}:     Done copying #{source_path} to #{destination_path}"
  end

  puts "#{Thread.current.object_id}: Done processing #{File.basename(file)} => #{annotated_file_path}."
end
