#!/usr/bin/env ruby
# encoding: UTF-8

require 'pry'
# resolve bin path, ignoring symlinks
require "pathname"
bin_file = Pathname.new(__FILE__).realpath

# add self to libpath
$:.unshift File.expand_path("../../lib", bin_file)

# Fixes https://github.com/rubygems/rubygems/issues/1420
require "rubygems/specification"

class Gem::Specification
  def this; self; end
end

require 'bundler/setup'
require 'stepmod/utils/stepmod_definition_converter'
require 'stepmod/utils/bibdata'
require 'stepmod/utils/concept'
require 'ptools'

ReverseAdoc.config.unknown_tags = :bypass

# TODO: we may want a command line option to override this in the future
ACCEPTED_STAGES = %w(IS DIS FDIS TS)

general_concepts = []
resource_concepts = []
module_concepts = []
parsed_bibliography = []
encountered_terms = {}

stepmod_dir = ARGV.first || Dir.pwd

def log message
  puts "[stepmod-utils] #{message}"
end

def term_special_category(bibdata)
  case bibdata.part.to_i
  when 41,42,43,44,45,46,47,51
    true
  when [56..112]
    true
  else
    false
  end
end

def part_to_title(bibdata)
  case bibdata.part.to_i
  when 41
    "Part 41"
  when 42
    "Geometric and topological representation"
  when 43
    "Foundation representation"
  when 44
    "Product structure, concept and configuration"
  when 45
    "Part 45"
  when 46
    "Visual presentation"
  when 47
    "Shape tolerance"
  when 51
    "Mathematical representation"
  else
    bibdata.title_en
  end
end

stepmod_path = Pathname.new(stepmod_dir).realpath

# If we are using the stepmod CVS repository, provide the revision number per file
has_cvs = File.which("cvs")
cvs_mode = has_cvs && Dir.exists?(stepmod_path.join('CVS'))

log "INFO: STEPmod directory set to #{stepmod_dir}."

if cvs_mode
  log "INFO: STEPmod directory is a CVS repository and will detect revisions."
  log "INFO: [CVS] Detecting file revisions can be slow, please be patient!"
else
  log "INFO: STEPmod directory is not a CVS repository, skipping revision detection."
end

log "INFO: Detecting paths..."

files = %w(
  resource.xml
  application_protocol.xml
  business_object_model.xml
  module.xml
  ).inject([]) do |acc, t|

    candidate_paths = Dir["#{stepmod_dir}/**/#{t}"]
    acc << candidate_paths

end.flatten.sort.uniq

max_encountered_refs_indexes = {}
parsed_schema_names = {}

files.each do |file_path|
  file_path = Pathname.new(file_path).realpath
  fpath = file_path.relative_path_from(stepmod_path)

  log "INFO: Processing XML file #{fpath}"
  current_document = Nokogiri::XML(File.read(file_path)).root

  bibdata = nil
  begin
    bibdata = Stepmod::Utils::Bibdata.new(document: current_document)
  rescue
    log "WARNING: Unknown file #{fpath}, skipped"
    next
  end

  unless ACCEPTED_STAGES.include? bibdata.doctype
    log "INFO: skipped #{bibdata.docid} as it is not one of (#{ACCEPTED_STAGES.join(", ")})."
    next
  end

  if bibdata.part.to_s.empty?
    log "FATAL: missing `part` attribute: #{fpath}"
    log "INFO: skipped #{bibdata.docid} as it is missing `part` attribute."
    next
  end

  revision_string = "\n// CVS: revision not detected"
  if cvs_mode
    # Run `cvs status` to find out version

    log "INFO: Detecting CVS revision..."
    Dir.chdir(stepmod_path) do
      status = `cvs status #{fpath}`

      unless status.empty?
        working_rev = status.split(/\n/).grep(/Working revision:/).first.match(/revision:\s+(.+)$/)[1]
        repo_rev = status.split(/\n/).grep(/Repository revision:/).first.match(/revision:\t(.+)\t/)[1]
        log "INFO: CVS working rev (#{working_rev}), repo rev (#{repo_rev})"
        revision_string = "\n// CVS working rev: (#{working_rev}), repo rev (#{repo_rev})\n" +
          "// CVS: revision #{working_rev == repo_rev ? 'up to date' : 'differs'}"
      end
    end
  end

  # read definitions
  part_concepts = []
  current_document.xpath('//definition').each do |definition|
    index = max_encountered_refs_indexes[bibdata.anchor] || 1
    term_id = definition['id']
    unless term_id.nil?
      if encountered_terms[term_id]
        log "FATAL: Duplicated term with id: #{term_id}, #{fpath}"
      end
      encountered_terms[term_id] = true
    end

    # Assume that definition is located in clause 3 of the ISO document
    # in order. We really don't have a good reference here.
    ref_clause = "3.#{index}"

    concept = Stepmod::Utils::Concept.parse(
      definition,
      reference_anchor: bibdata.anchor,
      reference_clause: ref_clause,
      file_path: fpath + revision_string
    )
    next unless concept

    unless term_special_category(bibdata)
      # log "INFO: this part is generic"
      general_concepts << concept
    else
      # log "INFO: this part is special"
      part_concepts << concept
    end

    max_encountered_refs_indexes[bibdata.anchor] = index + 1
    parsed_bibliography << bibdata
  end

  part_resources = []
  part_modules_arm = {}
  part_modules_mim = {}

  log "INFO: FILE PATH IS #{file_path}"
  case file_path.to_s
  when /resource.xml$/
    log "INFO: Processing resource.xml for #{file_path}"
    # Assumption: every schema is only linked by a single resource_docs document.
    current_document.xpath('//schema').each do |schema_node|
      schema_name = schema_node['name']
      if parsed_schema_names[schema_name]
        log "ERROR: We have encountered this schema before: #{schema_name} from path #{parsed_schema_names[schema_name]}, now at #{file_path}"
        next
      else
        parsed_schema_names[schema_name] = file_path
      end

      Dir["#{stepmod_path}/resources/#{schema_name}/descriptions.xml"].each do |description_xml_path|
        log "INFO: Processing resources schema #{description_xml_path}"
        description_document = Nokogiri::XML(File.read(description_xml_path)).root
        description_document.xpath('//ext_description').each do |ext_description|

          # log "INFO: Processing linkend[#{ext_description['linkend']}]"

          concept = Stepmod::Utils::Concept.parse(
            ext_description,
            reference_anchor: bibdata.anchor,
            reference_clause: nil,
            file_path: Pathname.new(description_xml_path).relative_path_from(stepmod_path)
          )
          next unless concept

          unless term_special_category(bibdata)
            # log "INFO: this part is generic"
            resource_concepts << concept
          else
            # log "INFO: this part is special"
            part_resources << concept
          end

          parsed_bibliography << bibdata
        end
      end
    end

  when /module.xml$/
    log "INFO: Processing module.xml for #{file_path}"
    # Assumption: every schema is only linked by a single module document.
    # puts current_document.xpath('//module').length
    schema_name = current_document.xpath('//module').first['name']
    if parsed_schema_names[schema_name]
      log "ERROR: We have encountered this schema before: #{schema_name} from path #{parsed_schema_names[schema_name]}, now at #{file_path}"
      next
    else
      parsed_schema_names[schema_name] = file_path
    end

    description_xml_path = "#{stepmod_path}/modules/#{schema_name}/arm_descriptions.xml"
    log "INFO: Processing modules schema #{description_xml_path}"

    if File.exists?(description_xml_path)
      description_document = Nokogiri::XML(File.read(description_xml_path)).root
      description_document.xpath('//ext_description').each do |ext_description|

        linkend_schema = ext_description['linkend'].split('.').first

        concept = Stepmod::Utils::Concept.parse(
          ext_description,
          reference_anchor: bibdata.anchor,
          reference_clause: nil,
          file_path: Pathname.new(description_xml_path).relative_path_from(stepmod_path)
        )
        next unless concept

        part_modules_arm[linkend_schema] ||= []
        part_modules_arm[linkend_schema] << concept
        # puts part_modules_arm.inspect
        parsed_bibliography << bibdata
      end
    end

    description_xml_path = "#{stepmod_path}/modules/#{schema_name}/mim_descriptions.xml"
    log "INFO: Processing modules schema #{description_xml_path}"

    if File.exists?(description_xml_path)
      description_document = Nokogiri::XML(File.read(description_xml_path)).root
      description_document.xpath('//ext_description').each do |ext_description|

        linkend_schema = ext_description['linkend'].split('.').first

        concept = Stepmod::Utils::Concept.parse(
          ext_description,
          reference_anchor: bibdata.anchor,
          reference_clause: nil,
          file_path: Pathname.new(description_xml_path).relative_path_from(stepmod_path)
        )
        next unless concept

        part_modules_mim[linkend_schema] ||= []
        part_modules_mim[linkend_schema] << concept
        # puts part_modules_mim.inspect
        parsed_bibliography << bibdata
      end
    end

  end

  log "INFO: Completed processing XML file #{fpath}"

  if part_concepts.empty?
    log "INFO: Skipping #{fpath} (#{bibdata.docid}) because it contains no concepts."
  elsif part_concepts.length < 3
    log "INFO: Skipping #{fpath} (#{bibdata.docid}) because it only has #{part_concepts.length} terms."

    part_concepts.each do |x|
      general_concepts << x
    end
  else
    fn = "03x-stepmod-#{bibdata.part}.adoc"
    File.open(fn, 'w') { |file|
      file.puts("== #{part_to_title(bibdata)}\n\n")
      file.puts(part_concepts.map(&:to_mn_adoc).join("\n"))
    }
    log "INFO: written to: #{fn}"
  end

  unless part_resources.empty?
    fn = "04x-stepmod-entities-resources-#{bibdata.part}.adoc"
    File.open(fn, 'w') { |file|
      file.puts("== #{part_to_title(bibdata)}\n\n")
      file.puts(part_resources.map(&:to_mn_adoc).join("\n"))
    }
    log "INFO: written to: #{fn}"
  end

  # puts "INFO: MODULE SIZE #{part_modules_arm.size} #{part_modules_mim.size}"

  if part_modules_arm.size + part_modules_mim.size > 0
    fn = "05x-stepmod-entities-modules-#{bibdata.part}.adoc"

    File.open(fn, 'w') { |file|
      file.puts("")

      unless part_modules_arm.empty?
        schema_name = part_modules_arm.first.first
        concepts = part_modules_arm.first.last

        # puts "SCHEMA NAME ARM: #{schema_name}"
        file.puts("== #{schema_name}\n\n")
        file.puts(concepts.map(&:to_mn_adoc).join("\n"))
      end

      file.puts("")

      unless part_modules_mim.empty?
        schema_name = part_modules_mim.first.first

        # puts "SCHEMA NAME MIM: #{schema_name}"
        concepts = part_modules_mim.first.last
        file.puts("== #{schema_name}\n\n")
        file.puts(concepts.map(&:to_mn_adoc).join("\n"))
      end

    }
    log "INFO: written to: #{fn}"
  end

end

File.open('031-stepmod-general.adoc', 'w') { |file|
  file.puts(general_concepts.map(&:to_mn_adoc).join("\n"))
}

File.open('041-stepmod-entities-resources.adoc', 'w') { |file|
  file.puts(resource_concepts.map(&:to_mn_adoc).join("\n"))
}

# File.open('051-stepmod-entities-modules.adoc', 'w') { |file|
#   file.puts(module_concepts.map(&:to_mn_adoc).join("\n"))
# }

log "INFO: written to: 031-stepmod-general.adoc"

File.open('991-generated-bibliography.adoc', 'w') { |file|
  file.puts(parsed_bibliography.map(&:to_mn_adoc).sort.uniq.join("\n"))
}

log "INFO: written to: 991-generated-bibliography.adoc"
