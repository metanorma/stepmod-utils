#!/usr/bin/env ruby
# encoding: UTF-8

require "pry"
# resolve bin path, ignoring symlinks
require "pathname"
bin_file = Pathname.new(__FILE__).realpath

# add self to libpath
$:.unshift File.expand_path("../../lib", bin_file)

# Fixes https://github.com/rubygems/rubygems/issues/1420
require "rubygems/specification"

module Gem
  class Specification
    def this; self; end
  end
end

require "bundler/setup"
require "stepmod/utils/terms_extractor"
require 'optparse'

def log(message)
  puts "[stepmod-utils] #{message}"
end

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options]"

  opts.on("-p", "--path STEPMOD_DATA_PATH", String, "Path to STEPmod CVS data directory") do |path|
    options[:stepmod_dir] = path
  end

  opts.on("-i", "--index INDEX_PATH", String, "Path to repository_index.xml") do |path|
    unless path.nil?
      options[:index_path] = Pathname.new(path).to_s
    end
  end

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end.parse!

stepmod_dir = options[:stepmod_dir]
if stepmod_dir.nil?
  raise StandardError.new("STEPmod data path not set, set with the `-p` option.")
else
  log "STEPmod data path: `#{stepmod_dir}`"
end

index_path = options[:index_path] || File.join(stepmod_dir, "repository_index.xml")
unless File.exists?(index_path)
  raise StandardError.new("Index file not present at #{index_path}, set with the `-i` option.")
else
  log "Repository index path: `#{index_path}`"
end

general_concepts,
resource_concepts,
parsed_bibliography,
part_concepts,
part_resources,
part_modules = Stepmod::Utils::TermsExtractor.call(stepmod_dir, index_path)

def part_to_title(bibdata)
  case bibdata.part.to_i
  when 41
    "Fundamentals of product description and support"
  when 42
    "Geometric and topological representation"
  when 43
    "Foundation representation"
  when 44
    "Product structure, concept and configuration"
  when 45
    "Material and other engineering properties"
  when 46
    "Visual presentation"
  when 47
    "Shape tolerance"
  when 51
    "Mathematical representation"
  else
    bibdata.title_en
  end
end

IMAGE_REPLACEMENTS = {
  'image::eq01.gif[]' => 'stem:[H(A,B) = max {h(A, B), h(B,A)}]',
  'image::eq02.gif[]' => 'stem:[max_{a in A} { min_{b in B} d(a,b) }]',
  'image::vector_z_c.gif[]' => 'stem:[bar z_{c}]',
  'image::one_direction_repeat_factor_expression.gif[]' => 'stem:[I + k cdot R;  k = -1, 1]',
  'image::two_direction_repeat_factor_expression.gif[]' => 'stem:[I + k_1 cdot R_1 + k_2 cdot R_2;  k_1, k_2 = -1, 0, 1, k^2_1 + k^2_2 != 0]'
}

def replace_images(content)
  IMAGE_REPLACEMENTS.each_pair do |k, v|
    content.gsub!(k, v)
  end

  content
end

part_concepts.each do |(bibdata, current_part_concepts)|
  current_part_concepts = current_part_concepts.to_a.map do |n|
    n.localizations["en"]
  end
  fn = "03x-stepmod-#{bibdata.part}.adoc"
  File.open(fn, "w") do |file|
    file.puts("== #{part_to_title(bibdata)}\n\n")
    file.puts(replace_images(current_part_concepts.map(&:to_mn_adoc).join("\n")))
  end
  log "INFO: written to: #{fn}"
end

File.open("03x-stepmod.adoc", "w") do |file|
  part_concepts.sort_by do |(bibdata, current_part_concepts)|
    bibdata.part.to_i
  end.each do |(bibdata, current_part_concepts)|
    fn = "03x-stepmod-#{bibdata.part}.adoc"
    file.puts("\ninclude::#{fn}[]\n")
  end
end

log "INFO: written summary file to: 03x-stepmod.adoc"

part_resources.each do |(bibdata, current_part_resources)|
  current_part_resources = current_part_resources.to_a.map do |n|
    n.localizations["en"]
  end
  fn = "04x-stepmod-entities-resources-#{bibdata.part}.adoc"
  File.open(fn, "w") do |file|
    # file.puts("== #{part_to_title(bibdata)}\n\n")
    file.puts(replace_images(current_part_resources.map(&:to_mn_adoc).join("\n")))
  end
  log "INFO: written to: #{fn}"
end

File.open("04x-stepmod-entities-resources.adoc", "w") do |file|
  part_resources.sort_by do |(bibdata, current_part_resources)|
    bibdata.part.to_i
  end.each do |(bibdata, current_part_resources)|
    fn = "04x-stepmod-entities-resources-#{bibdata.part}.adoc"
    file.puts("\ninclude::#{fn}[]\n")
  end
end

log "INFO: written summary file to: 04x-stepmod-entities-resources.adoc"

part_modules.each do |(bibdata, part_modules_arm, part_modules_mim)|
  fn = "05x-stepmod-entities-modules-#{bibdata.part}.adoc"
  File.open(fn, "w") do |file|
    file.puts("")
    unless part_modules_arm.empty?
      schema_name = part_modules_arm.first.first
      concepts = part_modules_arm.first.last.to_a.map do |n|
        n.localizations["en"]
      end

      # puts "SCHEMA NAME ARM: #{schema_name}"
      file.puts("== #{schema_name}\n\n")
      file.puts(concepts.map(&:to_mn_adoc).join("\n"))
    end

    file.puts("")

    unless part_modules_mim.empty?
      schema_name = part_modules_mim.first.first

      # puts "SCHEMA NAME MIM: #{schema_name}"
      concepts = part_modules_mim.first.last.to_a.map do |n|
        n.localizations["en"]
      end
      file.puts("== #{schema_name}\n\n")
      file.puts(replace_images(concepts.map(&:to_mn_adoc).join("\n")))
    end
  end
  log "INFO: written to: #{fn}"
end

File.open("05x-stepmod-entities-modules.adoc", "w") do |file|
  part_modules.sort_by do |(bibdata, part_modules_arm, part_modules_mim)|
    bibdata.part.to_i
  end.each do |(bibdata, part_modules_arm, part_modules_mim)|
    fn = "05x-stepmod-entities-modules-#{bibdata.part}.adoc"
    file.puts("\ninclude::#{fn}[]\n")
  end
end

log "INFO: written summary file to: 05x-stepmod-entities-modules.adoc"

File.open("031-stepmod-general.adoc", "w") do |file|
  file.puts(
    replace_images(
      general_concepts.to_a.map do |n|
        n.localizations["en"]
      end.map(&:to_mn_adoc).join("\n")
    )
  )
end

log "INFO: written to: 031-stepmod-general.adoc"

File.open("041-stepmod-entities-resources.adoc", "w") do |file|
  file.puts(
    replace_images(
      resource_concepts.to_a.map do |n|
        n.localizations["en"]
      end.map(&:to_mn_adoc).join("\n")
    )
  )
end
log "INFO: written to: 041-stepmod-entities-resources.adoc"

File.open("991-generated-bibliography.adoc", "w") do |file|
  file.puts(parsed_bibliography.map(&:to_mn_adoc).sort.uniq.join("\n"))
end
log "INFO: written to: 991-generated-bibliography.adoc"
